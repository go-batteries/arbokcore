I want to implement SSE for sending notifications/events on file chunk updates.

TO build a system as such, we need to hold the connection for each user_device pair in memory. For a simple system one server is enough.
And can be scaled vertically. 

If we try to scale it horizontally, we will need a way to make sure:

1. Distribute the connection pairs between the servers efficiently
2. If a node goes down, and comes back up, the users who were managed by that server should map to the same server
 - Redistribution is also something needed to be considered.
3. There are multiple ways of managing this. And for each way, the implementation can differ.

Lets consider using consistent hashing to map users to a server. And each user can have a mapping for devices.

Where to put the system which does this logic can be either done at a Gateway layer. (Kong/Custom HAP script/AWS Lmabda)
But that does make it a point of failure, so, one needs to have multiple instances of whatever system is being used.

For configuration like server_label to ip/url mapping, node status (up or down), can be build with zookeeper, etcd. 
And we might also need some service discovery system.

When a node comes up, someone needs to notify the systems. Anyway.

The second way would be to store the config in some in memory cache, and the servers periodically checking using heartbeat.

Each server then has to use the same hashing and mapping functionality. Across languages, it might pose a challange. But it depends
on the languages. And a hashing algorithm might not be so difficult to port.



The other way would be to use some range based splitting. with hashing we might end up with some hotspots. If we use some range paritioning, it would be possible to create a custom range to map some more demanding file to be sent to a different server with more capacity.





The other thing, I need to bring attention is, the system is monolithic, with the tokens and users along with metadata management.

This two systems have different load requirements. And it would make sense to split them into two databases. While it would be easy as
using two sqlite databases. We would have a problem with creating tokens.


According to the right choices for building a distributed system. Two services, if possible, shouldn't be interracting with each others
store. Especially writing.

Right now the CreateMetadataToken, creates a metadata entry and a token inside a transaction. If we split up the database. The functionality will also have to be split. And this brings us to one of the C's of Distributed System Design

Co-ordination.

It's how changes are communicated across systems to ensure consistency and causality in the system. They are two types:

- Orchestrated
- Coreographed


Orchestration generally requires a single point of origin to call multiple apis in order and handle error events for each action.
One can do it using a mediator. But often times, the initiating service will act as the mediator, probably also called the 
front controller.

The problem again with this component is single point of failure. Where as coreographed is when you communicate between services
via events only.
Given the set of events, you can always recreate the states, but then when has things ever gotten easier with events. 

More distributed the system is, the more chaotic it tends to be.

Some systems require orchestration, some can work with coreography. Something like a order placement, driver booking can benefit
from a orchestrated system. The orchestrated system has state involved. And it sortof is easier to implement once the actions on
failures are correctly identified, with proper cancellation.

Even cancellations has to be sent to required services.


So in our case, the metadata service has to co-ordinate with sessions service to create a token. In case it fail, it deletes the entry
and conveys that to the sessions service, in case it failed from timeout. 

At this moment, I want to focus on the SSE and come back to this later. 














Explicit tradeoff and backing up with requirements

